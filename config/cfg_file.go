// vi: sw=4 ts=4 noet:
/*
 ---------------------------------------------------------------------------
   Copyright (c) 2013-2015 AT&T Intellectual Property

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at:

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
 ---------------------------------------------------------------------------
*/


/*

	Mnemonic:	cfg_file	
	Abstract:	functions that make processing a configfile easier.
				A 'container' (Configure) is now provided with Extract_*
				functions which make it easier for a user to find a 
				key across multiple sections of the configuration file.

	Date:		27 December 2013
	Author:		E. Scott Daniels

	Mods:		30 Nov 2014 - allows for comments on key = value lines.
				11 Nov 2015 - Added ability to use += 
				21 Oct 2016 - Added Configure struct and related extract functions.
								Fixed bug that allowed "123" to be captured as a float
								rather than a string.

*/

/*
	Provides the means to open and parse a sectioned configuration file.
*/
package config

import (
	"bufio"
	"fmt"
	"io"
	"os"
	"strings"

	"github.com/att/gopkgs/clike"
	"github.com/att/gopkgs/token"
)


const (
	ET_INT	int = iota
	ET_INT64
	ET_UINT
	ET_FLOAT
	ET_STRING
	ET_STRINGP
)

/*
	Structure to wrap the map generated by Parse() allowing for the Extract_*
	funciton set to provide a simple interface to the user programme.
*/
type Config struct {
	data	map[string]map[string]interface{}
}

// -- generic parsing functions which yield maps ----------------------------------------

/*
	Parses a configuration file containing sections and key/value pairs within the
	sections.  Returns a map of sections (by name) with each entry in the map being
	a map[string]interface{}.  Key/values are converted and stored by the key name as
	either string pointers or float64s.  If the value is quoted, the quotes are removed.

	Section names may be duplicated which causes values appearing later in subsequent
	sections to be added to the previously encountered values.  Keys within each section
	must be uniqueue.  If a duplicate key is encountered, the last one read will be the
	one that ends up in the map.

	If all_str is true, then all values are returned as strings; no attempt is made
	to convert values that seem to be numeric into actual values as it  might make logic
	in the user programme a bit easier (no interface dreferences).
*/
func Parse( sectmap map[string]map[string]interface{}, fname string, all_str bool ) ( m map[string]map[string]interface{}, err error ) {
	var (
		rec		string;							// record read from input file
		sect	map[string]interface{};			// current section
		sname	string;							// current section name
		rerr	error = nil;					// read error
	)

	if sectmap != nil {
		m = sectmap;
		if m["default"] == nil {				// don't count on user creating a default section
			m["default"] = make( map[string]interface{} )
		}
	} else {
		m = make( map[string]map[string]interface{} );
		m["default"] = make( map[string]interface{} )
	}

	sname = "default";
	sect = m[sname];				// always start in default section

	f, err := os.Open( fname );
	if err != nil {
		return;
	}
	defer f.Close( );

	br := bufio.NewReader( f );
	for ; rerr == nil ; {
		rec, rerr = br.ReadString( '\n' );
		if rerr == nil {
			rec = strings.Trim( rec, " \t\n" );				// ditch lead/trail whitespace

			if len( rec ) == 0 { 					// blank line
				continue;
			}

			switch rec[0] {
				case ':':							// section
					//sname = rec[1:];
					_, tokens := token.Tokenise_qpopulated( rec, " \t" )		// easy way to ditch everything after the first token
					sname = tokens[0][1:]
					if m[sname]  == nil {
						sect = make( map[string]interface{} );
						m[sname] = sect;
					} else {
						sect = m[sname];
					}

				case '#':							// comment
					// nop

				case '<':
					m, err = Parse( m, rec[1:], all_str );
					if err != nil {
						return;
					}

				default:							// assume key value pair
					append := false
					first_tok := 1										// first token of var is 1, but could be later
					force_str := strings.Index( rec, "\"" ) != -1		// if a quote in the buffer, we force it to be a string

					ntokens, tokens := token.Tokenise_qpopulated( rec, " \t=" )
					if ntokens >= 2 {				// if key = "value" # [comment],  n will be 3 or more
						tl := len( tokens[0] )

						if tokens[0][tl-1:] == "+" {				//foo+= bar rather than foo = bar or foo += bar
							tokens[0] = tokens[0][:tl-1]
							append = true
						} else {
							if tokens[1] == "+" {					// += results in lone plus, not to be confused with +9999
								append = true
								first_tok++
							}
						}

						key := tokens[0]
						if tokens[first_tok] == "" {		// key = (missing value) given
							tokens[first_tok] = " "
						}
						fc := tokens[first_tok][0:1]
						if !force_str && !all_str && ((fc >= "0"  && fc <= "9") || fc == "+" || fc == "-") {		// allowed to convert numbers to float
							sect[key] = clike.Atof( tokens[first_tok] );
						} else {
							dup := ""
							sep := ""
							for i := first_tok; i < ntokens && tokens[i][0:1] != "#"; i++ {
								dup += sep + tokens[i]									// snarf tokens up to comment reducing white space to 1 blank
								sep = " "
							}
							if append && sect[key] != nil {
								if old_str, ok := sect[key].(*string); ok {
									dup = *old_str + " " + dup
								}
							}

							sect[key] = &dup
						}		
					}								// silently discard token that is just a key, allowing the default to override
			}
		}
	}

	if rerr != io.EOF {
		err = rerr;
	}

	return;
}

/*
	Parsees the named file keeping the values as strings, and then we convert each
	section map into a map of strings, allowing for a simpler interface if the
	user doesn't want us to do the numeric conversions.

	This may be easier for the caller to use as the returned values can be referenced
	with this syntax (assuming m is the returned map):
		m[sect][key]
*/
func Parse2strs( sectmap map[string]map[string]*string, fname string ) ( m map[string]map[string]*string, err error ) {
	var (
		im map[string]map[string]interface{};		// interface map returned by parse
	)

	im, err = Parse( nil, fname, true );
	m = nil;

	if err != nil {
		return;
	}

	if sectmap == nil {									// create a new one if user did not supply, else use theirs and overlay dups from the config
		m = make( map[string]map[string]*string );		// run each section and save them in a string map to return
	} else {
		m = sectmap;
	}

	for sect, smap := range im {
		if m[sect] == nil {							// could have existed in user supplied map
			m[sect] = make( map[string]*string ); 	// make it if not there
		}

		for k, v := range smap {
			m[sect][k] = v.(*string);
		}
	}

	return;
}

// --------- Config struct related functions ----------------------------------

/*
	Makes a config structure which provides an interface to the raw map loaded by the previous funcitons.
*/
func Mk_config( fname string ) ( conf *Config, err error ) {
	conf = &Config { }

	conf.data, err = Parse( nil, fname, false )

	return conf, err
}

/*
	Internal funciton to convert an interface into a supported desired value.
*/
func cvt2desired( v interface{}, desired int ) ( interface{} ) {
	switch v.(type) {

		case string:
			switch desired {
				case ET_STRING:		return v
				case ET_STRINGP: 	return &v
				case ET_INT:		return v.(int)
				case ET_UINT:		return v.(uint)
				case ET_INT64:		return v.(int64)
				case ET_FLOAT:		return v.(float64)
			}

		case *string:
			switch desired {
				case ET_STRING:		return *(v.(*string))
				case ET_STRINGP: 	return v
				case ET_INT:		return clike.Atoi( *(v.(*string)) )
				case ET_UINT:		return clike.Atou( *(v.(*string)) )
				case ET_INT64:		return clike.Atoll( *(v.(*string)) )
				case ET_FLOAT:		return clike.Atof( *(v.(*string)) )
			}

		case float64:
			switch desired {
				case ET_STRING:		return fmt.Sprintf( "%.2f", v )
				case ET_STRINGP: 	s := fmt.Sprintf( "%.2f", v )
									return &s
				case ET_INT:		return int( v.(float64) )
				case ET_UINT:		return uint( v.(float64) )
				case ET_INT64:		return int64( v.(float64) )
				case ET_FLOAT:		return v
			}

		case int:
			switch desired {
				case ET_STRING:		return fmt.Sprintf( "%d", v )
				case ET_STRINGP: 	s := fmt.Sprintf( "%d", v )
									return &s
				case ET_INT:		return v
				case ET_UINT:		return uint( v.(int)  )
				case ET_INT64:		return int64( v.(int) )
				case ET_FLOAT:		return float64( v.(int) )
			}

		case int64:
			switch desired {
				case ET_STRING:		return fmt.Sprintf( "%d", v )
				case ET_STRINGP: 	s := fmt.Sprintf( "%d", v )
									return &s
				case ET_INT:		return int( v.(int64) )
				case ET_UINT:		return uint( v.(int64) )
				case ET_INT64:		return v
				case ET_FLOAT:		return float64( v.(int64) )
			}

		case bool:
			switch desired {
				case ET_STRING:		return fmt.Sprintf( "%v", v )
				case ET_STRINGP: 	s := fmt.Sprintf( "%v", v )
									return &s
				case ET_INT:		if v.( bool ) { 
										return int( 1 )
									} else {
										return int( 0 )
									}
				case ET_UINT:		if v.( bool ) { 
										return uint( 1 )
									} else {
										return uint( 0 )
									}
				case ET_INT64:		if v.( bool ) { 
										return int64( 1 )
									} else {
										return int64( 0 )
									}
				case ET_FLOAT:		if v.( bool ) {
										return 1.0
									} else {
										return 0.0
									}
			}
	}

	return nil
}

/*
	The Extract_* functions search the configuration for a [section][key] pair and return the 
	value of the first pair found, or the default value if no value is found. The sections
	searched are supplied as a space separated string (sect_list) which is searched in order.
*/

/*
	The work horse behind any of the Extract_* functions
*/
func ( cfg *Config ) extract_something( sect_list string, key string, def_value interface{},  desired int ) ( val interface{} ) {
	if cfg == nil {
		return cvt2desired( def_value, desired )
	}

	stokens := strings.Split( sect_list, " " )
	for _, sect := range stokens {
		v := cfg.data[sect][key]
		if v != nil {
			return cvt2desired( v, desired )
		}
	}

	return cvt2desired( def_value, desired )
}


/*
	Extract_p2str will search the configuration in sect_list order for the given key string.
	The value associated with the key is converted to a string, and a pointer to that string
	is returned. If the key does not exist in any of the sections listed, then the default value
	is returned.  The default value (def_val) may be either a string, or a pointer which should
	make the invoking code more straight forward. The default value may be a nil pointer.
*/
func ( cfg *Config ) Extract_p2str( sect_list string, key string, def_value interface{} ) ( val *string ) {
	v := cfg.extract_something( sect_list, key, def_value, ET_STRING )	// yes we want a string back
	if v == nil {
		return nil
	}

	s := v.( string )
	return  &s
}

/*
	Extract_float will search the configuration in sect_list order for the given key string.
	The value associated with the key is converted to a float64 value and returned to the caller.
	If the key is not found in any named section, then the default value is returned.
*/
func ( cfg *Config ) Extract_float( sect_list string, key string, def_value interface{} ) ( val float64 ) {
	v := cfg.extract_something( sect_list, key, def_value, ET_FLOAT )
	return v.( float64 )
}

/*
	Extract_int64 will search the configuration in sect_list order for the given key string.
	The value associated with the key is converted to a 64 bit integer value and returned to the caller.
	If the key is not found in any named section, then the default value is returned.
*/
func ( cfg *Config ) Extract_int64( sect_list string, key string, def_value interface{} ) ( val int64 ) {
	v := cfg.extract_something( sect_list, key, def_value, ET_INT64 )
	return v.( int64 )
}

/*
	Extract_int will search the configuration in sect_list order for the given key string.
	The value associated with the key is converted to a integer value and returned to the caller.
	If the key is not found in any named section, then the default value is returned.
*/
func ( cfg *Config ) Extract_int( sect_list string, key string, def_value interface{} ) ( val int ) {
	v := cfg.extract_something( sect_list, key, def_value, ET_INT )
	return v.( int )
}

/*
	Extract_uint will search the configuration in sect_list order for the given key string.
	The value associated with the key is converted to an unsigned integerinteger value and returned to the caller.
	If the key is not found in any named section, then the default value is returned.
*/
func ( cfg *Config ) Extract_uint( sect_list string, key string, def_value interface{} ) ( val uint ) {
	v := cfg.extract_something( sect_list, key, def_value, ET_UINT )
	return v.( uint )
}

/*
	Extract_str will search the configuration in sect_list order for the given key string.
	The value associated with the key is converted to a string and returned to the caller.
	If the key is not found in any named section, then the default value is returned.
*/
func ( cfg *Config ) Extract_str( sect_list string, key string, def_value interface{} ) ( val string ) {
	v := cfg.extract_something( sect_list, key, def_value, ET_STRING )
	return v.( string )
}

/*
	Dump will spit the hashes to stder.
*/
func ( cfg *Config ) Dump() {
	for s, h := range cfg.data  {
		fmt.Fprintf( os.Stderr, "\n:%s\n", s )
		for k, v := range h {
			switch av := v.(type) {
				case *string:
					fmt.Fprintf( os.Stderr, "  %s = %s\n", k, *av )

				case float64:
					fmt.Fprintf( os.Stderr, "  %s = %.2f\n", k, av )
			}
		}
	}
}
